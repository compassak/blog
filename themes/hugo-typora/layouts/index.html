{{ define "main" }}
<div class="homepage-wrapper">
    <!-- Particle Effect Container (z-index: 0, below content) -->
    <div id="particle-container"></div>

    <!-- Hero Section -->
    <section class="hero-section">
        <div class="hero-content">
            <h1 class="hero-title">
                {{ with .Site.Params.hero.title }}{{ . | safeHTML }}{{ else }} title {{ end }}
            </h1>
            <p class="hero-description">
                {{ with .Site.Params.hero.description }}{{ . }}{{ else }}description{{ end }}
            </p>
        </div>
    </section>

    <!-- Recent Posts Grid -->
    <section id="posts-grid" class="posts-grid-container">
        <div class="posts-grid">
            {{ range first 20 .Site.RegularPages }}
            <a href="{{ .RelPermalink }}" class="post-card">
                {{ $img := (.Resources.ByType "image").GetMatch "*featured*" }}
                {{ with $img }}
                <div class="post-card-image">
                    <img src="{{ .RelPermalink }}" alt="{{ $.Title }}">
                </div>
                {{ end }}
                <div class="post-card-content">
                    <div class="post-card-meta">
                        <span class="post-date">{{ .Date.Format "2006-01-02" }}</span>
                        {{ with .Params.categories }}
                        <span class="post-category">{{ index . 0 }}</span>
                        {{ end }}
                    </div>
                    <h3 class="post-card-title">{{ .Title }}</h3>
                    <p class="post-card-summary">{{ .Summary | truncate 100 }}</p>
                    <span class="read-more">Read more &rarr;</span>
                </div>
            </a>
            {{ end }}
        </div>
    </section>
</div>

<!-- Three.js Particle Effect -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
<script>
    (function () {
        let scene, camera, renderer, particles, particleSystem;
        const particleCount = 5000;
        const mouse = new THREE.Vector2(9999, 9999);
        const velocities = [];
        const positions = [];

        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0xffffff, 0.001);
            scene.background = new THREE.Color(0xffffff);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 2000);
            camera.position.z = 1000;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);

            const container = document.getElementById('particle-container');
            if (container) {
                container.appendChild(renderer.domElement);
            }

            createParticleSystem();

            window.addEventListener('resize', onWindowResize);
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('touchmove', onTouchMove, { passive: false });
        }

        function createParticleSystem() {
            const geometry = new THREE.BufferGeometry();

            for (let i = 0; i < particleCount; i++) {
                const x = (Math.random() - 0.5) * 2000;
                const y = (Math.random() - 0.5) * 2000;
                const z = (Math.random() - 0.5) * 2000;
                positions.push(x, y, z);

                velocities.push(
                    (Math.random() - 0.5) * 0.2,
                    (Math.random() - 0.5) * 0.2,
                    (Math.random() - 0.5) * 0.2
                );
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));

            const material = new THREE.PointsMaterial({
                color: 0x444444,
                size: 4,
                transparent: true,
                opacity: 0.6,
                map: new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/disc.png'),
                sizeAttenuation: true
            });

            particleSystem = new THREE.Points(geometry, material);
            scene.add(particleSystem);
        }

        function animate() {
            requestAnimationFrame(animate);
            render();
        }

        function render() {
            const positionsArray = particleSystem.geometry.attributes.position.array;
            const time = Date.now() * 0.0005;

            for (let i = 0; i < particleCount; i++) {
                const index = i * 3;
                let px = positionsArray[index];
                let py = positionsArray[index + 1];
                let pz = positionsArray[index + 2];

                let vx = velocities[index];
                let vy = velocities[index + 1];
                let vz = velocities[index + 2];

                vx += Math.sin(time + py * 0.01) * 0.005;
                vy += Math.cos(time + px * 0.01) * 0.005;
                vz += Math.sin(time + pz * 0.01) * 0.005;

                const mouseVector = new THREE.Vector3(
                    (mouse.x / window.innerWidth) * 2 - 1,
                    -(mouse.y / window.innerHeight) * 2 + 1,
                    0.5
                );
                mouseVector.unproject(camera);
                const dir = mouseVector.sub(camera.position).normalize();
                const distanceToCamera = -camera.position.z / dir.z;
                const mousePosInWorld = camera.position.clone().add(dir.multiplyScalar(distanceToCamera));

                const dx = px - mousePosInWorld.x;
                const dy = py - mousePosInWorld.y;
                const distSq = dx * dx + dy * dy;
                const forceRadiusSq = 250 * 250;

                if (distSq < forceRadiusSq) {
                    const dist = Math.sqrt(distSq);
                    const force = (forceRadiusSq - distSq) / forceRadiusSq;

                    vx += (dx / dist) * force * 2.5;
                    vy += (dy / dist) * force * 2.5;
                    vz += (Math.random() - 0.5) * force * 1.5;
                }

                vx *= 0.98;
                vy *= 0.98;
                vz *= 0.98;

                px += vx;
                py += vy;
                pz += vz;

                const boundary = 1000;
                if (px > boundary) px = -boundary;
                if (px < -boundary) px = boundary;
                if (py > boundary) py = -boundary;
                if (py < -boundary) py = boundary;
                if (pz > boundary) pz = -boundary;
                if (pz < -boundary) pz = boundary;

                positionsArray[index] = px;
                positionsArray[index + 1] = py;
                positionsArray[index + 2] = pz;
                velocities[index] = vx;
                velocities[index + 1] = vy;
                velocities[index + 2] = vz;
            }

            particleSystem.geometry.attributes.position.needsUpdate = true;

            particleSystem.rotation.y += 0.0005;
            particleSystem.rotation.x += 0.0002;

            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onMouseMove(event) {
            mouse.x = event.clientX;
            mouse.y = event.clientY;
        }

        function onTouchMove(event) {
            if (event.touches.length > 0) {
                mouse.x = event.touches[0].clientX;
                mouse.y = event.touches[0].clientY;
                event.preventDefault();
            }
        }
    })();
</script>

<style>
    #particle-container {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 0;
        pointer-events: none;
    }

    #particle-container canvas {
        display: block;
    }
</style>
{{ end }}